% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hexcarto.R
\name{hexcarto2b}
\alias{hexcarto2b}
\title{Create a hexagonal cartogram map}
\usage{
hexcarto2b(shp, pop_field, choro_field, jenks = c(TRUE, FALSE), colval,
  label_field, quant_carto_breaks = c(TRUE, FALSE))
}
\arguments{
\item{shp}{The spatial object to be read in, providing the coordinates and the dbf}

\item{pop_field}{The name of the population field within the data set that will later be transformed to provide the weights}

\item{choro_field}{The name of the optional field with the values that will later go onto provide the values for the choropleth map}

\item{colval}{The name of the optional field that if true, will provide colors by polygon for the map. Note that if this field and the 
choro/jenks fields are empty, then the map will be made blue. The colval field should take the form of a value that can be recognized as 
as color (i.e. blue). Can also be manipulated before hand by the user so that it reflects some non-jenks categorization of values.}

\item{label_field}{The name of the field with polygon labels, which if filled, will overlay the polygons with names.}

\item{quant_carto_breaks}{The True/False field as to how the user wants the population weights. If true, then the weights will be transformed
such that the weights will be broken by the values quantile (i.e. pops in fifth pct will have size weight of 0.05). False, and the values 
will be the normalized population values, which might result in oddities if the population is not normally distributed.}
}
\value{
The dataframe and plot of the map will be provided, with the following fields: 
    \itemize{
    \item xcor = The x coordinate for the centroid of the hexagon
    \item ycor = The y coordinate for the centroid of the hexagon
    \item pop_field = The populations of the polygonal units provided  
    \item color_field = The color values for the polygon 
    \item norm_pop = The normalized population values on a 0 - 1 scale
    \item label = If user provided, the labels of the polygons 
    \item norm_pop2 = The quantile apportioned weights for the map   
    
}
}
\description{
This function takes shapefiles with a population field and first converts the maps to a hexagonal grid, and then weights areas with 
higher populations to appear larger
}
\examples{
mi_shp <- readOGR(eguia_path, "mi_county_shp")
test_hexagon <- hexcarto2b(mi_shp,pop_field="VAP2010",choro_field="gop_vote_s",jenks = TRUE,quant_carto_breaks = TRUE)

}
